# Debugger Detection
Debuggers are an essantial part of analysis, so malware tries to disrupt them. I'll make a document on anti-static analysis later.
### Timing Analysis
Breakpoints and stepping can be detected by timing analysis. API's used include QueryPerformanceCounter, GetTickCount(64), RDTSC, and GetSystemTime. The following pesudo code represents how most of these API's work:
```go
call WhatsTheTime
edx := eax // EAX is usually were the time is stored
blah := blah //random stuff here
call WhatsTheTime
eax := eax - edx //Find time since first WhatsTheTime call
if (eax > 2ms) {
    print("Debugger detected, you loose!")
}
```
### Exception Detection
Debuggers use exceptions to operate, such as the single step exception, or the int 3 exception. Software can use this to see if a debugger will handle the exception itself, it can also be used to stop the process for the debugger, the message shown will usually be: Exception x detected, don't handle it? Yes (pass to app), No (handle exception)
Paired with the above detection method, this can be used to detect a debugger. Here's some pesudo code to show what I just explained:
```python
Try:
    bob = 0/0 # Cause a divide by 0 error
    print("Debugger detected, you loose!")
except Exception:
    print("No debugger detected, good job!")
    
```
Paired with time:
```python
import time
Try:
    h = current.time()
    bob = 0/0
    print("Debugger detected, you loose!")
except Exception:
    print("Test 1 passed, but did you fail the second?")
    c = current.time()
    b = h-c
    if (c > 100ms):
        print("Yeah you lost")
    else:
        print("Both tests passed!")
```
Lastly, some assembly code (generated by chatGPT) to recongugnize what to look for:
```
; Set up the exception handler
xor eax, eax
push eax ; exception handler flags
lea eax, DivideByZeroExceptionHandler
push eax ; exception handler function address
push dword 0 ; exception code (divide by zero)
push dword [fs:0] ; exception record pointer
mov  dword [fs:0], esp

; Perform the division operation
mov  eax, 10
mov  ebx, 0
div  ebx ; division by zero

; If the division is successful, skip the exception handling code
jmp  Done

; Exception handler function
DivideByZeroExceptionHandler:
    pushad ; save registers
    mov   eax, [esp + 0x28] ; get the exception record
    cmp   dword [eax + 0x18], 0xC0000094 ; check if exception is divide by zero
    jne   HandleOtherException

    ; Handle divide by zero exception
    xor   eax, eax ; set return value to 0
    jmp   Done

HandleOtherException:
    ; Handle other types of exceptions here
    ; ...

Done:
    popad ; restore registers

```
### PEB Based Detection
This is the most commonly used method of debugger detection. All of the following API's use the PEB for detecting debuggers (most of these are API's used for other things, but they can be used for debugger detection):
* ZwQuerySystemInformation
* IsDebuggerPresent
* NtQueryInformationProcess
* CheckRemoteDebuggerPresent (uses NtQueryInformationProcess)
All of these API's can be used to detect if a debugger is present, and they all use the same(ish) method, they look at the PEB structure to see if it's being debugged.
Here's code that does the same thing, except it uses the actual PEB, not an API:
```
mov eax, dword ptr fs:[18h] //Mov the address of TEB into eax (Thread Information Block)
mov eax, dword ptr fs[eax+30h] //Mov the address of PEB into eax, 30h is how far into the TEB PEB is
movzx eax, byte ptr ds:[eax+2h] //Mov the byte of the debugger flag into eax, 2h is how far in this flag is
```
If eax isn't 0, a debugger has been detected. 
### Process/Window Name Detection
This is a pretty comprehensable method of detection, if a debugger name is in the process list, a debugger has been detected. Same with window names. Here's some common API's used for this (this is a small list, the full list is 20+ API's):
* EnumWindows 
* EnumChildWindows
* CreateToolhelp32Snapshot
* QueryFullProcessImageName
I'll be explaining each one, first we have EnumWindows. This, unsuprizingly, enumerates window names (on the screen)! EnumChildWindows does the same thing, but with sub windows. CreateToolhelp32Snapshot is a more intresting one, it's usually paired with Process32first and Process32Next. This can be used for checking process names and parent process IDs. Here's some assembly showing how CreateToolHelp32Snapshot can be used:
```
include windows.inc
include kernel32.inc
includelib kernel32.lib

.data
szProcessName db "x64dbg",0

.code
main PROC
    ; Create a snapshot of the system processes
    mov eax, TH32CS_SNAPPROCESS
    xor ebx, ebx
    invoke CreateToolhelp32Snapshot, eax, ebx
    
    ; Check if the snapshot was successfully created
    cmp eax, INVALID_HANDLE_VALUE
    jne start_loop
    
    ; If the snapshot creation failed, exit the program
    invoke ExitProcess, 1
    
start_loop:
    ; Initialize the PROCESSENTRY32 structure
    mov dword ptr [ebp-44], 0
    mov dword ptr [ebp-40], 0
    mov word ptr [ebp-36], SIZEOF PROCESSENTRY32
    mov ebx, offset szProcessName
    mov dword ptr [ebp-32], ebx
    
    ; Iterate over the system processes
    mov eax, [ebp-8]
    mov dword ptr [eax+4], SIZEOF PROCESSENTRY32
    invoke Process32First, [ebp-8], [ebp-44]
    
    .WHILE eax
        ; Check if the process name matches
        cmp dword ptr [ebp-44+28], offset szProcessName
        jne next_process
        
        ; Print the process ID to the console
        invoke StdOut, offset szProcessName, 0
        invoke StdOut, offset ": ", 0
        mov eax, [ebp-44+8]
        invoke WriteDec, eax
        invoke StdOut, offset "\n", 0
        
next_process:
        ; Move to the next process in the snapshot
        mov eax, [ebp-8]
        invoke Process32Next, eax, [ebp-44]
    .ENDW
    
    ; Close the snapshot handle and exit the program
    invoke CloseHandle, [ebp-8]
    invoke ExitProcess, 0
main ENDP

END main
```
###  Misc
I've only covered some more common methods, but here I'm going to cover some other methods used (process injection/self injection is out of scope for this document, also I haven't learned how to debug multiple threads yet, course will be updated when I do). TLS callbacks can be used to execute code before the entry point, you can find TLS data in the .TLS section of a binary, most normal binarys don't have it may be suspicous if a binary does have it. 
